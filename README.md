# IoT
# ROS(Robot Operating System)

요즘 스마트홈은 서버에 연결되어 원격으로 제어하거나 타이머를 맞춰 놓는 간단한 형태가 아니라 집에서 로봇이 돌아다니는 형태로 바뀜

→ 그곳에 들어가는 SW의 개발을 도와주는 역할을 한다.

- 로봇을 개발하는데 있어 필수적인 라이브러리 제공
- Application 부분만 개발하면되기 때문에 개발 시간, 비용 절약 효과

- 메타 운영체제라고 한다. OS 위에 설치하고 OS에 있는 기능들을 이용하여 스케줄링, 감시, 에러처리 등을 처리한다. → 이러한 컨셉을 미들웨어, 소프트웨어 프레임워크라고 한다.
  - 새로운 OS를 배우는게 아니라 ROS에서 만들어놓은 Client Library를 이용해서 원하는 기능을 수행하는 Node(프로그램)을 만드는 것

:white_check_mark: TCP/UDP → DDS(Data Distribution Service) :  네트워크에 존재하는 통신 객체들을 자동으로 검색하고 데이터의 연관성에 따라 선택적으로 연결을 수행 → 다수의 로봇, 장치를 연결하기에 효과적이다.

:white_check_mark: 기존은 Master라는 노드가 직접 연결을 해줬다면 ROS2는 Master가 따로 존재하지 않고 분산되어 처리, Master가 죽어서 모든 시스템이 마비되는 걱정을 하지 않아도 됨

## ROS 용어

1. 노드

   노드는 ROS에서 최소 단위의 실행 프로세스를 가리키는 용어, 즉 하나의 파이썬 스크립트는 하나의 노드이다.

2. 메시지

   노드에서 다른 노드로 정보를 전달하는 단방향, 비동기식, 연속적 통신 → 기능 별로 노드를 나눠서 만들기 때문에 편리한 기능이다.

3. 패키지

   ROS 소프트웨어의 기본 단위, 패키지는 노드, 라이브러리, 환경설정 파일들을 통합하는 최소의 빌드 단위이며, 배포 단위이다.

![ROS용어](README.assets/ROS용어.png)

### 메세지 통신

노드 간 데이터 교환을 쉽게 해주는 것을 메시지 통신이라고 하며 ROS의 핵심 기능이다.

- Talker는 메시지를 발행(Publish)하는 노드, Listener는 메시지를 구독(Subscribe)하는 노드
- 2가지 요소를 알면(Topic, Type) 발행, 구독 가능
- Topic: chatter, Type: std msgs/String, 내용 : hello world
- 토커에서 리스너로만 보낸다(단방향 통신)
- 메시지를 리스너가 원할 때만 받는 것이 아니라 토커가 보낼 때마다 받는다. → 받고 싶지 않아도 계속 받아지기 때문에 `비동기식 연속성 통신`이라고 한다.
- 하나의 노드에서만 받을 수 있는 것이 아니라 다른 노드에서 Subscriber를 만들어서 가능하다(/chatter(std msgs/String)
- 패키지는 여러개의 노드를 가질 수 있다.

### 통신 방법

1. setup.bat 파일을 호출해서 터미널에서 ROS의 기능을 사용할 수 있게 해야 한다(새로운 터미널을 열 때마다 호출 해야한다.)

   call C:\dev\ros2_eloquent\setup.bat → 아무것도 뜨지 않으면 ROS가 잘 설치되었고 사용할 수 있다는 것

2. Node를 2개 사용해야하기 때문에 새로운 터미널을 열어야함, 이후 setup.bat을 다시 호출 해야한다.

3. 메세지를 퍼블리시하는 토커를 실행

   ros2 run demo_nodes_cpp talker → 토커에서 메시지를 퍼블리시 하고 있다고 출력됨(받는 노드가 없어도 계속 퍼블리시 가능)

4. 리스너를 실행

   ros2 run demo_nodes_py listener → 키는 순간 퍼블리시에서 보내는 메시지를 받음

⇒ 메시지 통신을 시켜주는 기능 → 나중에는 센서 데이터, 주행 명령어, 인지 결과 등 다양한 데이터를 메시지를 통해서 보냄

**결과**

![msg통신](README.assets/msg통신.png)

## 노드와 메시지 관련 명령어

현재 어떤 노드가 실행되고 있고 어떤 메세지가 나오고 있으며, 데이터는 무엇인지, 어떤 노드에서 어떤 노드로 메시지가 흘러가는지 파악 가능하다.

→ 디버깅에 편리하다.

### 노드 명령어

- ros2 node list : 실행되고 있는 노드 이름 출력

  ![node_list](README.assets/node_list.png)

- ros2 node info /talker : talker 노드의 통신 상태, 내용 출력\

  ![node_info](README.assets/node_info.png)

### 토픽(메시지) 명령어

- ros2 topic list : publish 되고 있는 메시지 리스트 출력

  ![topic_list](README.assets/topic_list.png)

  현재 talker에서 publish되고는 chatter라는 topic이 있다라는 것을 보여준다.

  밑에 두개는 ROS가 실행되면 기본적으로 나오는 메시지라 신경 안써도 된다.

- ros2 topic echo /chatter : /chatter의 메시지 내용을 출력

  ![topic_echo](README.assets/topic_echo.png)

- ros2 topic pub /test std_msgs/msg/Float64 "{data: 10}"

  ![topic_pub](README.assets/topic_pub.png)

## ROS 장점

- 노드간 메시지 교환 방법으로 복잡한 프로그램을 나눠 공동 개발 용이
  - 예) 자율 주행 차량
  - 하나의 노드(스크립트)에서 알고리즘을 개발할 때 인지, 판단, 제어를 나눠서 개발한다고 하면 서로 스크립트를 계속 공유하면서 개발하거나 앞단의 알고리즘이 개발이 끝나야 다음 사람이 다음 알고리즘을 개발할 수 있다. 또한 앞단에서 개발한 알고리즘이 뒤에 있는 알고리즘의 성능에도 영향을 미칠 수 있다. ⇒ 하나의 노드에서 개발하기 때문에 발생하는 문제
- ROS를 사용한다면 서로 노드간의 주고받을 토픽과 메시지 타입만 알려주면 결과를 전송해줄 수 있기 때문에 기능별로 노드를 나눠서 개발할 수 있다. 공동으로 작업하는대도 서로에게 전혀 영향을 주지 않는다.
- 기능별로 노드를 만들었기 때문에 문제 발생 시, 어느 노드에서 메시지가 나오지 않는지 파악하면 쉽게 해결할 수 있다.
- 로봇 소프트웨어를 개발할 때 라이다, 카메라, GPS와 같이 센서 데이터 받는 것에 대한 걱정할 필요가 없음
  - 로봇에 주로 사용하는 각종 센서들은 제조사에서 ROS로 만들어서 제공하고 있거나 누군가 이미 만들어 놓은 센서 드라이브를 깃허브 같은 곳에 공유하고 있기 때문에 패키지만 받아서 빌드하면 데이터를 받을 수 있다 → 개발 시간 단축
- ROS에서 만들어 놓은 여러가지 표준 메시지 타입들이 있다. STD msgs, NAV msgs, SENSOR msgs 등 사용자가 미리 사용할만한 타입들을 만들어 놓았다. → 사용자가 따로 메시지 타입을 정의해서 사용할 필요가 없다.
- 강력한 시각화 도구가 있다.
  - RQT
    - rqt topic monitor : 현재 나오고 있는 토픽들을 모니터링 할 수 있는 토픽 모니터가 있다(토픽 관련 명령어의 시각화 버전)
    - rqt graph : 어떤 노드에서 어떤 토픽이 나오고 어떤 노드로 들어가고 있는지 한눈에 볼 수 있게 해주는 시각화 도구(전체적인 시스템을 한눈에 파악할 때 사용) → 우리가 설치한 버전에는 설치가 안되어있음
  - RVIZ : 미리 만들어져있는 표준 메시지 타입을 사용하면 바로 시각화해서 만들어주는 툴
  - ROSBAG : 시각화 도구 외에도 현재 퍼블리시 되고 있는 메시지들을 기록했다가 재생할 수 있는 도구
    - 실제 테스트했던 환경에서 나온 메시지들을 가지고 있다가 원하는 때에 플레이해서 사용할 수 있다. 마치 실험 환경에 있는 것과 같이 코드를 개발할 수 있다.
    - 반복적인 실험으로 알고리즘 개발에 용이
    - 실제 실험 환경에 있는 것과 같이 코드를 개발 및 수정 가능

**ROS 장점 정리 ⇒ 오로지 개발자가 소프트웨어에 집중할 수 있게 개발에 필요한 다양한 툴을 제공 → 시간과 비용 절약**